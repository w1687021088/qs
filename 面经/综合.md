## 1. 单页应用如何提高加载速度？
使用代码分割：将代码拆分成小块并按需加载（懒加载），以避免不必要的网络请求和减少加载时间。
缓存资源：利用浏览器缓存来存储重复使用的文件，例如 CSS 和 JS 文件、图片等。
预加载关键资源：在首次渲染之前，先提前加载关键资源，例如首页所需的 JS、CSS 或数据，以保证关键内容的快速呈现。
使用合适的图片格式：选择合适的图片格式（例如 JPEG、PNG、WebP 等），并根据需要进行压缩以减少文件大小。对于一些小图标，可以使用 iconfont 等字体文件来代替。
启用 Gzip 压缩：使用服务器端的 Gzip 压缩算法对文件进行压缩，以减少传输时间和带宽消耗。
使用 CDN：使用内容分发网络（CDN）来缓存和传递文件，以提高文件的下载速度和可靠性。
优化 API 请求：尽可能地减少 API 调用的数量，并使用缓存和延迟加载等技术来优化 API 请求的效率。
使用服务器端渲染：使用服务器端渲染（SSR）来生成 HTML，以减少客户端渲染所需的时间和资源。但需要注意，SSR 也可能增加了服务器的负担并使网站更复杂。


## common.js 和 es6 中模块引入的区别？

从这道题目我们可以很容易地引申出来另外一道“明星”面试题：common.js 和 es6 中模块引入的区别？

CommonJS 是一种模块规范，最初被应用于 Nodejs，成为 Nodejs 的模块规范。运行在浏览器端的 JavaScript 由于也缺少类似的规范，在 ES6 出来之前，前端也实现了一套相同的模块规范 (例如: AMD)，用来对前端模块进行管理。自 ES6 起，引入了一套新的 ES6 Module 规范，在语言标准的层面上实现了模块功能，而且实现得相当简单，有望成为浏览器和服务器通用的模块解决方案。但目前浏览器对 ES6 Module 兼容还不太好，我们平时在 Webpack 中使用的 export 和 import，会经过 Babel 转换为 CommonJS 规范。在使用上的差别主要有：

1、CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。

2、CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。

3、CommonJs 是单个值导出，ES6 Module可以导出多个

4、CommonJs 是动态语法可以写在判断里，ES6 Module 静态语法只能写在顶层

5、CommonJs 的 this 是当前模块，ES6 Module的 this 是 undefined

## tree shaking如何工作的呢？

Tree shaking 代码优化方案，旨在删除模块代码中未使用到的代码，减小项目体积大小；

工作原理： 

ES6 Module引入进行静态分析，故而编译的时候正确判断到底加载了那些模块;

静态分析程序流，判断那些模块和变量未被使用或者引用，进而删除对应代码；

备注： commonjs 是动态的，无法知道哪些模块在运行前需不需要；Es6 import 可以，因为它是静态的









## CommonJS和ES6模块的区别

两者皆是模块

commonjs输出的是一个值的拷贝，es6 模块输出的是一个值的引用；

commonjs运行时加载，es6 模块是编译时输出；

因为两个模块加载机制的不同，所以在对待循环加载的时候，它们会有不同的表现。CommonJS遇到循环依赖的时候，只会输出已经执行的部分，后续的输出或者变化，是不会影响已经输出的变量。而ES6模块相反，使用import加载一个变量，变量不会被缓存，真正取值的时候就能取到最终的值；

块顶层的this指向问题，在CommonJS顶层，this指向当前模块；而在ES6模块中，this指向undefined；

关于两个模块互相引用的问题，在ES6模块当中，是支持加载CommonJS模块的。但是反过来，CommonJS并不能requireES6模块，在NodeJS中，两种模块方案是分开处理的

## 堆栈

内存场景：

栈内存：

用于存储原始数据类型，以及引用数据类型的指针；

每个方法执行时，都会创建自己的内存栈，方法内创建的变量将逐个存储到内存栈中，等到方法执行结束，则内存栈销毁（闭包除外，如果闭包用了内存栈的变量时，则闭包将会把内存栈的数据保存下来，一直等待闭包结束）

堆内存：

用于存储引用数据类型的值(地址)；

当在程序中创建一个对象，这个对象将存储在堆内存中用来程序反复利用，如果改对象被别的方法使用时，并不会随着方法执行结束而销毁，会在程序停止引用该对象后才会被垃圾回收机制将在某个时期内回收该内存；

数据场景：

栈：

有序的数据结构， 先进后出的表现方式；

堆：

无序的数据结构，key-value 方式；

队列：

队列的特点就是先进先出，数据存储从尾部插入，头部取出；

## 执行上下文

执行上下文是在代码执行过程中创建的抽象环境概念，它包含了代码执行所需的所有信息，比如变量、函数、对象的引用以及作用域链等。每当 JavaScript 代码被执行，就会创建一个执行上下文。

全局执行上下文（Global Execution Context）：

整个脚本或模块的默认执行上下文，位于最顶层，拥有全局变量和全局函数。

函数执行上下文（Function Execution Context）：

每当函数被调用时，都会创建一个对应的函数执行上下文，用于保存函数的局部变量、参数和函数内部的声明。

Eval 函数执行上下文（Eval Function Execution Context）：

与 eval 函数相关的执行上下文，不推荐使用 eval，因为它会导致作用域问题。

执行栈

执行栈指的是用来存储 js 代码运行时所创建的所有执行上下文环境；

当 js 引擎首先运行 js 代码时，创建全局执行上下文，并压入执行栈中；

同样每当遇到函数执行时，也会为它创建函数执行上下文压入执行栈；

执行栈优先从栈顶部开始，当顶部的上下文环境执行结束，执行上下文冲栈中弹出，控制流程交到当前执行栈的下一个上下文中，直到结束；

## 事件循环

1. js 是单线程的，代码从上往下运行
2. 代码分为：同步、异步；先同步、后异步
3. 异步分为：宏任务、微任务； 先宏任务、后微任务（注意：全局 Script 算一个宏任务）
4. 每当运行一段同步代码时，都会将代码压入调用栈中，等代码执行完毕以后出栈，当调用栈为空时，对于这两个任务队列的检测情况步骤如下：
5. 检测微任务队列是否为空，若不为空则取第一个进栈执行，执行结束后接着重复此步骤，若为空，则本轮事件循环结束，接着下一个任务（宏任务检测）；
6. 检测宏任务队列是否为空，若不为空则取第一个进栈执行，然后按步骤 5 处理，若为空，则直接执行第一步骤；

ui render 将在一轮循环事件结束之后，期间如果有 requestAnimationFrame 函数方法，将先调用该方法，在进行 UI render；

而 requestIdleCallback 调用将先检查 ui render 是否要结束，如果距离下一帧还有剩余事件的话就执行，如果时间不够将在下一帧执行；


微任务 - 宏任务

调用栈 -> 首先执行同步代码，执行完成后出栈，检测任务队列（宏任务队列，微任务队列），

宏任务队列，微任务队列，


首次： script 是个宏任务，初始微任务队列为空，宏任务队列只有一个 script；

js 引擎开始执行代码，宏任务取第一个压入调用栈执行，同步代码执行，异步代码分为宏任务加入宏任务队列，微任务加入微任务队列；



宏任务：

script, setInterval, setTimeout, UI renderer

微任务：

promise.then promise.catch

## 作用域（Scope）

作用域指的是变量和函数在代码中的可访问范围。在 JavaScript 中，作用域可以分为两种类型：

全局作用域（Global Scope）：

位于最顶层，包含了在整个代码中都可以访问的变量和函数。

局部作用域（Local Scope）：

由函数、块语句（如 if、for）等创建，包含了在特定区域内可访问的变量和函数。

## 作用域链

作用域链就是从当前作用域开始一层一层向上寻找某个变量，直到找到全局作用域还是没找到，就宣布放弃


