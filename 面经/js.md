## 1: 在 javaScript 中 this 指的是什么

在 `javaScript` 中， `this` 是一个`关键字`，用于指向函数的`执行上下文`。

它的值取决于函数的调用方式。在`全局作用域`中，this指向`全局对象`（在浏览器环境中是window对象）。在`函数`中，this的值取决于`函数的调用方式`，可以是`函数的拥有者对象`（当函数作为对象的方法调用时），也可以是`new关键字创建的新对象`（当函数作为构造函数调用时），还可以是`使用call()或apply()方法指定的对象`（当函数通过这两个方法调用时）。此外，在`箭头函数中，this的值是在定义函数时确定`的，它捕获了函数所在上下文的this值。
函数被调用的方式

1: 全局函数调用

```js
const foo = function () {
    return this
}

foo() // this = undeined | window | glodal
```

2: 作为引用数据类型的方法被调用

```js

const object = {
    foo() {
       return this 
    }
}

object.foo() // this = object


const objFun = object.foo


objFun() // this = undeined | window | glodal

// 箭头函数

const object = {
    foo() {
        return this
    },
    fcc: () => this
}

object.foo() === object // true this === object

object.fcc() ==== object // false this === undefined | window | glodal

```

3: 构造函数内调用

```js

function Foo() {
    this.name = 'foo'
}


const foo = new Foo() // this === foo

```

原型方法（call、apply、bind）下修改函数的 this 指向

```js
```

小技巧
```js
const object = {
    method: function () {
        // 其他逻辑
    }
}

object.method(/** ...args */) === method.call(object, /** ...args */) // this = object

function method() {
    // 其他逻辑
}

method() === method.call(undefined, /** ...args */) // this = undefined | window | glodal

```


## 2. 浏览器有哪几种缓存，各种缓存的优先级是什么样的？

1 Service Worker 缓存: 由于其可以完全控制网络请求，因此具有最高的优先级，即使是强制缓存也可以被它所覆盖
2 强制缓存：如果存在强制缓存，并且缓存没有过期，则直接使用缓存，不需要向服务器发送请求
3 协商缓存：如果强制缓存未命中，但协商缓存可用，则会向服务器发送条件请求，询问资源是否更新。
4 Web Storage 缓存: Web Storage 缓存的优先级最低，只有在网络不可用或者其他缓存都未命中时才会生效

## 3.  webpack5 模块联邦的了解？

Webpack 5 的模块联邦（Module Federation）是一种新的技术，可以实现多个独立 Webpack 构建之间的共享模块和代码。它通过让每个构建的应用程序能够使用其他应用程序中的模块来提高代码共享和复用的效率

Module Federation 的主要优势包括：

多个应用程序之间可以共享代码和模块，从而减少重复代码量。
应用程序可以更加灵活地划分为更小的子应用程序，从而降低应用程序的复杂度。
可以避免在应用程序之间传递大量数据，从而提高应用程序的性能和效率。
可以支持应用程序的动态加载和升级，从而实现更好的版本管理和迭代。

## 4. ToPrimitive 的理解

ToPrimitive 是一个抽象操作，用于将一个值转换为原始值（primitive value），即字符串、数字或布尔值

## 5. 什么是作用域链？

作用域，即变量（变量作用域又称上下文）和函数生效（能被访问）的区域或集合;

一般将作用域分成：

全局作用域

函数作用域

块级作用域

当在Javascript中使用一个变量的时候，首先Javascript引擎会尝试在当前作用域下去寻找该变量，如果没找到，再到它的上层作用域寻找，以此类推直到找到该变量或是已经到了全局作用域

如果在全局作用域里仍然找不到该变量，它就会在全局范围内隐式声明该变量(非严格模式下)或是直接报错

## 6. 对 requestIdleCallback 的理解

requestIdleCallback 是一个浏览器 API，它允许我们在浏览器空闲时执行一些任务，以提高网页的性能和响应速度

## 7. 对函数式编程的理解，以及优缺点？

函数式编程是一种编程范式，（强调结果非过程，倡导多个执行单元）

相比命令式编程，函数式编程更加强调程序执行的结果而非执行的过程

概念：
他的概念就是旨在尽可能提高代码的无状态性和不可变性；

函数式编程的概念有以下四种：

纯函数 = 无状态 + 数据不变

高阶函数 = 就是以函数作为输入或者输出的函数被称为高阶函数

柯里化 = 把一个多参数函数转化成一个嵌套的一元函数的过程

组合函数 = 目的是将多个函数组合成一个函数

优点

更好的管理状态：因为它的宗旨是无状态，或者说更少的状态，能最大化的减少这些未知、优化代码、减少出错情况

更简单的复用：固定输入->固定输出，没有其他外部变量影响，并且无副作用。这样代码复用时，完全不需要考虑它的内部实现和外部影响

更优雅的组合：往大的说，网页是由各个组件组成的。往小的说，一个函数也可能是由多个小函数组成的。更强的复用性，带来更强大的组合性

隐性好处。减少代码量，提高维护性

缺点：

性能：函数式编程相对于指令式编程，性能绝对是一个短板，因为它往往会对一个方法进行过度包装，从而产生上下文切换的性能开销

资源占用：在 JS 中为了实现对象状态的不可变，往往会创建新的对象，因此，它对垃圾回收所产生的压力远远超过其他编程方式

递归陷阱：在函数式编程中，为了实现迭代，通常会采用递归操作

## 8. 图片是否可见

1 设置 img 的属性 loading = lazy
2 滚动方式
3 交叉观察器

## 9. 尾递归

尾递归，即在函数尾位置调用自身（或是一个尾调用本身的其他函数等等）。尾递归也是递归的一种特殊情形。尾递归是一种特殊的尾调用，即在尾部直接调用自身的递归函数


## 10. js函数有哪几种声明方式？有什么区别？

有 表达式 和 声明式 两种函数声明方式

声明式: function， 意味着函数提升，在当前作用域内可以在任意位置调用

表达式：var let const，不会函数提升，调用必须在函数声明之后调用；

## 11. 如何把一个对象变成可迭代对象？ 就是 可以被 for 。。。of 迭代

给对象添加一个`[Symbol.iterator]`属性，并且该方法返回一个迭代器对象，这样的对象即可称为可迭代对象

## 12. 如何判断某个字符串长度（要求支持表情）？

```js
'哈哈😄123'.length // 7


console.log([...'哈哈😄123'].length); // 6


```

## 13. js中数组是如何在内存中存储的？
堆内存
## 14. 从输入url，到页面的画面展示的过程
1、首先，在浏览器地址栏中输入url

2、浏览器先查看浏览器缓存-系统缓存-路由器缓存，如果缓存中有，会直接在屏幕中显示页面内容。若没有，则跳到第三步操作。

3、在发送http请求前，需要域名解析(DNS解析)，解析获取相应的IP地址。

4、浏览器向服务器发起tcp连接，与浏览器建立tcp三次握手。

5、握手成功后，浏览器向服务器发送http请求，请求数据包。

6、服务器处理收到的请求，将数据返回至浏览器

7、浏览器收到HTTP响应

8、读取页面内容，浏览器渲染，解析html源码

9、生成Dom树、解析css样式、js交互,渲染显示页面

浏览器下载HTML后，首先解析头部代码，进行样式表下载，然后继续向下解析HTML代码，构建DOM树，同时进行样式下载。当DOM树构建完成后，立即开始构造CSSOM树。理想情况下，样式表下载速度够快，DOM树和CSSOM树进入一个并行的过程，当两棵树构建完毕，构建渲染树，然后进行绘制。

Tips:浏览器安全解析策略对解析HTML造成的影响：

当解析HTML时遇到内联JS代码，会阻塞DOM树的构建，会先执行完JS代码;当CSS样式文件没有下载完成时，浏览器解析HTML遇到了内联JS代码，此时，浏览器暂停JS脚本执行，暂停HTML解析。直到CSS文件下载完成，完成CSSOM树构建，重新恢复原来的解析。

JavaScript 会阻塞 DOM 生成，而样式文件又会阻塞 JavaScript 的执行，所以在实际的工程中需要重点关注 JavaScript 文件和样式表文件，使用不当会影响到页面性能的。

## 15. 如何确保你的构造函数只能被new调用，而不能被普通调用？

可以通过 instanceof 
```js
if (!(this instanceof XX)) {
    throw '....'
} 

```

es6 new.target

```js
function Person() {
    console.log(new.target);
}
// new: Person {}
console.log("new: ",new Person())
// not new: undefined
console.log("not new:", Person())
```

尽量使用 class 

## 16. 浏览器一帧都会干些什么？

## 17. 为什么JavaScript是单线程？

JavaScript的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。

为了避免复杂性，从一诞生，JavaScript就是单线程，这已经成了这门语言的核心特征，将来也不会改变。

为了利用多核CPU的计算能力，HTML5提出Web Worker标准，允许JavaScript脚本创建多个线程，但是子线程完全受主线程控制，且不得操作DOM。所以，这个新标准并没有改变JavaScript单线程的本质。

